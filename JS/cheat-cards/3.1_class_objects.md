# JavaScript Objects & Prototypes

---

## Concepts:

### class:

- `Class` define objects with **initialization (constructors)**, **data (fields)**, and **behavior (methods)**.
- Syntactic sugar over prototypes for defining constructors + methods in a cleaner way.
- Unlike functions, `class` declarations are **not hoisted**.
- Class bodies are always strict (`"use strict"`).
  ```js
  new C(); // ❌ ReferenceError
  class C {}
  ```

#### Features

- `Constructor`
  - Initializes instance (only one per class).
  - Subclass must call `super()` **before using `this`**. else it will throw ReferenceError.
  - Missing `super()` in subclass → ReferenceError.
  - Only one Constructor allowed. Overloads not supported (simulate with defaults or static factories).
- `Instance methods`
  - Defined on `Class.prototype`.
  - Instance methods go on `prototype`.
  - Instance methods can’t call static ones via `this`, use `ClassName.method()`.
- `Static methods`
  - Belong to the class itself. Not available on instance.
  - Use static methods for utilities required in class but not tied to object or instance.
  - Useful for utilities, factories, helpers.
  - Inherited by subclasses, But also can be shadowed in subclass.
  - `this` in static method refers to the class itself, not instance.
- `Class Fields (ES2022)`
  - define properties directly.
  - Declared inside class body, outside constructor, Initialized newly per-instance.
  - Public fields accessible via instance.
  - Be cautious with reference types (arrays, objects) — each instance gets its own.
- `Private fields`
  - `#field` (true privacy prefixed with `#`) Not accessible via bracket notation.
  - Not accessible outside class.
  - Not dynamically accessible (`obj["#field"]` ❌).
  - Separate from normal props (`obj.#x` ≠ `obj.x`).
  - `this.#x` and `this["#x"]` are unrelated.
  - `#` fields replace Old-style `WeakMap` or closures for privacy.
  - Not inherited by subclasses.
  - Supported for:
    - Instance fields: `#count = 0;`
    - Static fields: `static #registry = new Map();`
    - Methods: `#helper(){...}`
    - Getters/Setters: `get #id(){...}`
- `Getters/Setters`
  - via `get` / `set`.
  - Avoid heavy logic in getters (unexpected slowdowns).
  - Overusing getters for hot properties may slow down compared to direct access.
  - Use Getters for Abstraction, safety, computed logic, or public APIs only.
  - Recursive setter if not careful:
    ```js
    set name(v){ this.name=v; } // ❌ infinite loop name will keep calling itself
    ```
- `Inheritance`
  - `extends` for subclassing.
  - Extending built-ins (`Array`, `Error`) may behave inconsistently across engines.
  - Need `super()` call to properly initialize.
- `super`
  - call parent constructor/method.

#### Syntax

```js
class Person {
  // Constructor
  constructor(name, age = 18) {
    this.name = name;
    this.age = age;
  }
  // Instance method
  sayHi() {
    return `Hi, ${this.name}`;
  }
  // Static method
  static species() {
    return "Homo sapiens";
  }
  // Public field
  x = 10; // 10
  // Private field
  #x = x; // 10  Different properties, no conflict.
  // Getter
  get double() {
    return this.#x * 2;
  }
  // Setter
  set double(v) {
    this.#x = v / 2;
  }
}
const p = new Person("Kalidas"); // Instance i.e object of the class
p.sayHi(); // "Hi, Kalidas" // Instance method
p.species(); // new Person().species() ❌  Static method not available on instance
Person.species(); // "Homo sapiens" // Static method available on class
p.x; // 10 // Public field
p.#x; // ❌ Private field not accessible outside class
p.double; // 20 // Getter access via property :no `()` required
p.double = 20; // Setter
```

#### alert⚠️

- `Binding this`
  - Methods aren’t auto-bound. Passing to callbacks loses context.
  - Fix: arrow functions in class fields or manual `bind`.
- Defining methods inside constructor instead of `prototype` creates per-instance copies → memory bloat.
- `new.target`
  - Inside constructor, `new.target` refers to constructor called.
  - Useful for abstract base classes.
- `Symbol properties`
  - Class methods can use computed names (`[Symbol.iterator]() {}`), but not private + symbol together.

---

### Inheritance

- Inheritance in JS uses the **prototype chain** and ES6 `class` syntax adds `extends`, `super` for clarity.

```js
// Inheritance
class Animal {
  speak() {
    return "sound";
  }
}
class Dog extends Animal {
  speak() {
    return super.speak() + " woof"; // super.speak() calls parent's method
  }
}
new Dog().speak(); // "sound woof"
```

#### Super

- `super(...)` → calls parent constructor (must be first in subclass constructor).
- `super.method(...)` → calls parent’s method.
- `super` only valid in constructors/methods, not in nested functions.
  - Fix: use arrow functions or bind context.
    ```js
    class A {
      greet() {
        console.log("Hi from A");
      }
    }
    class B extends A {
      super.greet(); // ✅ parent method
      greet() {
        super.greet(); // ✅ parent method
        function inner() {super.greet()} // ❌ SyntaxError: 'super' not allowed here
        const inner = () => super.greet(); // ✅ works - Arrows don’t bind `super`. They use the enclosing scope’s `super`.
        inner();
      }
    }
    ```
- `super` with getters/setters → works
- `class fields` before `super` → field initializers always run **after super()**.
  ```js
  class A {}
  class B extends A {
    x = 10; // ❌ runs AFTER super()
    constructor() {
      // console.log(this.x); // ❌ Cannot access before super()
      super();
      console.log(this.x); // ✅ 10
    }
  }
  ```
- `Object.setPrototypeOf` hazards → manually altering inheritance chain can break `super`.
  | Case | Need `super(...)`? | Example |
  | ------------------------------------------------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | **Base class (no `extends`)** | ❌ Not allowed | `class A {  constructor() { this.x = 1; } // ✅ works directly}` |
  | **Subclass, no constructor** | ❌ Auto-inserted by JS | `class A { constructor(n) { this.n=n; } } ->  class B extends A {(js auto calls super())} -> // Internally same as constructor(...args){ super(...args); }` |
  | **Subclass with constructor** | ✅ Must call first | `class A { constructor(x){this.x=x;} } -> class B extends A {  constructor(x,y){    super(x);   // ✅ must be first    this.y=y;  }}` |
  | **Subclass, parent has no constructor** | ✅ Still required | `class A {} // no constructor → default empty -> class B extends A {  constructor(){    super();   // ✅ still required ->  this.z=10;  }}` |
  | **Subclass constructor doesn’t need parent args** | ✅ But can be empty | `class A { constructor(){ console.log("A"); } } -> class B extends A {  constructor(){    super();   // ✅ required, no args  ->  this.type="dog";  }}` |
  | **Subclass constructor doesn’t define itself** | ❌ No explicit call needed (auto) | `class A { constructor(){ console.log("A"); } } -> class B extends A {} -> new B(); // Js auto calls super()` |
  | **Trying to use `this` before `super(...)`** | ❌ Error | `class B extends A {  constructor(){    this.z=5;  // ❌ ReferenceError    super();  }}` |
  **alert ⚠️**: In **subclasses**, `super(...)` must be the **first statement** in the constructor before using `this`.

---

| Place               | Usage                                     | Example                                                                                                                                                            |
| ------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Instance method** | `super.method()` → parent instance method | `class A { greet(){ console.log("Hi from A"); } } -> class B extends A {  greet(){    super.greet(); // ✅ parent method    console.log("Hi from B");  }}`         |
| **Static method**   | `super.method()` → parent static method   | `class A { static hi(){ console.log("Hello A"); } } -> class B extends A {  static hi(){    super.hi(); // ✅ parent static method    console.log("Hello B");  }}` |
| **Constructor**     | `super(...)` → parent constructor         | `class A { constructor(x){ this.x=x; } }class B extends A {  constructor(x,y){    super(x); // ✅ parent constructor    this.y=y;  }}`                             |

#### Multiple Inheritance

- JavaScript does not support multiple inheritance directly.

```js
// ❌ Not supported directly
class A {}
class B {}
class C extends A, B {} // ❌ SyntaxError
```

- We can simulate it using
  - `Object.assign`(Not preferred)
    - Not preferred because it copies properties into a class prototype.
    - Works for simple trait mixing, but it’s shallow, can silently overwrite, breaks getters/setters, and doesn’t support super.
      ```js
      const canCode = {
        code() {
          console.log("Coding");
        },
      };
      const canDesign = {
        design() {
          console.log("Designing");
        },
      };
      class Engineer {}
      Object.assign(Engineer.prototype, canCode, canDesign); // #Objects are passed
      const e = new Engineer();
      e.code(); // Coding
      e.design(); // Designing
      ```
      - Pros:
        - Simple & direct.
        - Works with any class.
      - Cons:
        - Shallow copy only.
        - No `super` support.
        - Getters/setters lost.
        - Silent overwrites.
  - `composition`(Preferred for functions/State/Behavior Separation)
    - Best for encapsulation & testability.
    - Build objects by **holding smaller objects**, not inheriting them.
      ````js
        function canWalk(){ return { walk: () => console.log("Walking") }; }
        function canEat(){ return { eat: () => console.log("Eating") }; }
        // #functions are passed
        function Person(name){
          return {
            name,
            ...canWalk(),
            ...canEat()
          };
        }
        const p = Person("Kalidas");
        p.walk(); // Walking
        p.eat();  // Eating
        ```
        - Pros:
          - No prototype chain confusion.
          - Clear ownership of behavior.
          - Easier to test/replace parts.
        - Cons:
          - More boilerplate wiring.
          - Not integrated with `class` hierarchy.
      ````
  - `mixins`(Preferred for Classes)
    - Best balance of reusability + clarity.
    - Use **mixin factories**: functions that take a base and return an extended class.
    - Order of mixins = inheritance order.
      ```js
      class Animal {}
      const CanFly = (
        Base // #functions are passed -> Animal()
      ) =>
        class extends Base {
          fly() {
            console.log("Flying");
          }
        };
      const CanSwim = (
        Base // #functions are passed -> canFly(Animal())
      ) =>
        class extends Base {
          swim() {
            console.log("Swimming");
          }
        };
      class Duck extends CanSwim(CanFly(Animal)) {}
      const d = new Duck();
      d.fly(); // Flying
      d.swim(); // Swimming
      ```
      - Pros:
        - Works with `class` syntax.
        - Reusable behaviors.
        - Prototype chain preserved.
      - Cons:
        - Order-sensitive.
        - `super` fragile if methods overlap.

---

### Object vs Map

- Both store key–value pairs, but with different design, performance, and use-cases.

#### Object

```js
const obj = { a: 1 };
obj["b"] = 2;
```

- Keys: `strings & symbols` only.
- Prototype by default (`__proto__`).
- Not ordered (though ES6+ preserves insertion for string keys in practice).
- Best for structured data, simple records.

---

## Best Practices:

- Use `class` for clear OOP-like structures.
- Use constructor for setup only; keep logic in methods.
- Subclass with constructor → ✅ must call `super(...)` first.
- Keep methods on prototype (default) for memory efficiency.
- Use static methods for utilities related to class but not tied to instance.
- Keep static & instance methods conceptually separate.
- Use **fields** for default values and privacy (`#private`).
- Prefer **fields + private `#`** for encapsulation.
- Use **getters** for computed properties, formatting, lazy evaluation.
- Use **setters** for validation + sanitization.
- Don’t put heavy logic or side effects in getters.
- Inheritance
- Use `extends` + `super` for clear inheritance.
- Don’t mutate prototypes after class creation.
- Multiple Inheritance:
  - class-based designs (modern JS): ➝ Mixins.
  - functional/clean design: ➝ Composition (functions returning behaviors).
  - legacy/quick patching: ➝ `Object.assign` traits (but avoid for production).
- Don’t treat JS classes as classical OOP — still prototype-based.
- Use arrow fields for callbacks to preserve `this`.
- Use **Object** for structured, JSON-like data.
- Use **Map** for dynamic key sets, frequent inserts/deletes, or non-string keys.

---

## Mnemonics

- “Class = Constructor + Methods + Static + Inherit + super.”
- “Constructor = setup, Methods = behavior, Static = utils for class, Fields = data, #private = encapsulation & privacy, Getter = computed read, Setter = controlled write, Inherit = hierarchy, super = parent, arrow = this.”
- “`extends` links, `super` calls.”
- “Object = Record, Map = Dictionary.”

---
