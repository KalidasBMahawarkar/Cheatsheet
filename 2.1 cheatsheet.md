Perfect ‚Äî here‚Äôs your **Concept Mastery Cheat Sheet** for **JavaScript Functions & Scope**, ultra-compact but complete, with all **gotchas grouped in one block**.

---

# üîß JavaScript Functions & Scope ‚Äî Cheat Card

**Concept:** Functions encapsulate logic, define scope, and control variable visibility.

---

### Function Types

```js
// Declaration (hoisted)
function foo(a,b){ return a+b; }

// Named Expression
const bar = function mul(a,b){ return a*b; }; // Name is only visible inside function body

// Anonymous Expression
const bar = function(a,b){ return a*b; };

// Arrow (lexical `this`, no prototype)
const baz = (a,b) => a-b;

// Constructor
const obj = new Function("a","b","return a+b");

// IIFE (Immediately Invoked)
(function(){ console.log("run"); })();
```

---

### Scope Types

* **Global** ‚Üí accessible everywhere (window/globalThis).
* **Function** ‚Üí vars inside function, not outside.
* **Block** ‚Üí `let`/`const` (since ES6).
* **Lexical Scope** ‚Üí inner funcs access outer vars.
* **Module Scope** ‚Üí each ES module has its own top-level scope.

---

### Closures

* Function **remembers variables** from outer scope even after outer function exits.

```js
function outer(){ let x=0; return ()=>++x; }
const inc = outer();
inc(); // 1
inc(); // 2
```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Hoisting quirks**

   * Function declarations hoisted fully.
   * Function expressions/arrow funcs not hoisted.
   * Duplicate function names ‚Üí last one wins (sloppy mode).
2. **`this` pitfalls**

   * Regular function ‚Üí `this` depends on caller.
   * Arrow function ‚Üí inherits `this` from surrounding scope.
   * In strict mode, standalone function call ‚Üí `this = undefined`.
   * Losing context:

     ```js
     const m = obj.method; m(); // `this` lost
     ```
3. **Arguments object**

   * Not an array; array-like.
   * Doesn‚Äôt track parameter changes in strict mode.
   * Arrow functions have no `arguments`.
4. **Default params**

   * Evaluated at call time, left-to-right.
   * Using earlier param:

     ```js
     function f(a,b=a+1){}
     ```
   * `function f(a=a){}` ‚Üí ReferenceError (TDZ).
5. **Scope quirks**

   * `var` ignores block scope (`if`, `for`).
   * Shadowing outer vars may cause confusion.
   * Closures inside loops with `var`:

     ```js
     for(var i=0;i<3;i++) setTimeout(()=>console.log(i)); // 3,3,3
     ```
6. **Return behavior**

   * `return` ends function immediately.
   * Newline after `return` ‚Üí returns `undefined` (ASI trap- automatic semicolon insertion trap).
7. **Function constructor**

   * Creates functions from strings.
   * Always in global scope; ignores closures.
   * Security + performance issues.
8. **Named vs anonymous funcs**

   * Name shows up in stack trace.
   * Named function expressions useful for recursion.
9. **Strict mode differences**

   * `delete functionName` ‚Üí SyntaxError.
   * Functions in blocks disallowed in ES5 strict (later allowed in ES6).
10. **Recursion limits**

    * JS engines have stack size limits ‚Üí stack overflow on deep recursion.
11. **Arrow function gotchas**

    * No `this`, no `arguments`, no `super`, no `new.target`.
    * Not constructible (`new (()=>{})` ‚Üí TypeError).
12. **Default exports**

    * Functions as default export must be named for stack traces.
13. **Eval/with interactions**

    * `eval` can create vars in enclosing scope (sloppy mode).
    * `with` alters scope chain unpredictably (deprecated).

---

### Best Practices

* Prefer **function declarations** for hoisting; use **arrow functions** for callbacks.
* Use `const` when assigning functions.
* Avoid `var` to prevent leakage outside blocks.
* Use **closures** intentionally for state, not accidentally.
* Always include braces and return explicitly.
* Don‚Äôt use Function constructor (`new Function`).
* Keep scope shallow; modularize code.

---

üëâ Mnemonic: **‚ÄúDeclare, Scope, Closure, This, Args, Return.‚Äù**


---

# üÜö Function Declarations vs Function Expressions ‚Äî Cheat Card

**Concept:** Two main ways to define functions in JS, differing in hoisting, scope, and behavior.

---

### Function Declaration

```js
function add(a,b){ return a+b; }
```

* **Named** function.
* Hoisted (usable before definition).
* Exists in enclosing scope.
* Real-World Usage:
  * **Utility functions:** Common helpers like formatDate(), calculateTax().
  * **Service methods:** Core business logic functions in service layers.
  * **Library APIs:** Often exposed as declarations so they‚Äôre available anywhere in the file/module.
* Provide stability and predictability ‚Äî you know they exist before runtime.

---

### Function Expression

```js
const add = function(a,b){ return a+b; };   // anonymous
const mul = function multiply(a,b){ return a*b; }; // named expression
```

* Can be **anonymous** or **named**.
* Not hoisted (only variable declaration is).
* Assigned to variable/property.
* Real-World Usage:
  * **Event listeners:** button.addEventListener("click", () => { ... }).
  * **Promises / async flows:** .then(value => { ... }).
  * **Higher-order functions:** arr.map(x => x * 2).
  * **Callbacks:** Passing inline logic without polluting global/module scope.
* Provide flexibility and scoping control ‚Äî used where functions are values, passed around, or need closure context.


---

### Arrow Function Expression

```js
const sub = (a,b) => a-b;
```

* Concise syntax, always expression.
* Lexical `this`, no `arguments`, not constructible.

---

### Key Differences

| Aspect             | Declaration       | Expression                                         |
| ------------------ | ----------------- | -------------------------------------------------- |
| **Hoisting**       | Fully hoisted     | Only variable hoisted (function not initialized)   |
| **Naming**         | Always named      | Can be anonymous or named                          |
| **When available** | Anywhere in scope | Only after assignment                              |
| **Use case**       | Define main logic | Inline callbacks, closures, functional programming |

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Hoisting traps**

   ```js
   sayHi(); // works
   function sayHi(){ console.log("hi"); }

   greet(); // ‚ùå TypeError
   var greet = function(){ console.log("hey"); };
   ```

   * Declared funcs hoist fully.
   * Expressions hoist var only (undefined).
2. **Block scope differences**

   * In strict mode, function declarations inside blocks may behave inconsistently (ES6 standardized them as block-scoped).
3. **Named function expressions**

   * Name is only visible inside function body.
   * Useful for recursion:

     ```js
     const fact = function f(n){ return n<=1?1:n*f(n-1); };
     ```
   * Outside, `f` is not defined.
4. **Overwriting declarations**

   * Multiple declarations in same scope ‚Üí last one wins.
   * In strict ES6 modules, redeclaring in same scope throws.
5. **TDZ with let/const**

   ```js
   foo(); // ReferenceError
   let foo = function(){}; 
   ```

   * Expressions with `let`/`const` in TDZ until declared.
6. **Arrow vs declaration**

   * Arrow functions cannot be used as constructors.
   * Arrow functions don‚Äôt bind their own `this`/`arguments`.
7. **Function constructor**

   * `new Function("a","b","return a+b")` ‚Üí always expression, never hoisted, ignores closures (global scope only).
8. **Default exports in ES modules**

   * Function declarations exported as default are named only if explicitly given; function expressions may show as `default`.

---

### Best Practices

* Use **declarations** for top-level functions (readability + hoisting).
* Use **expressions/arrow funcs** for inline callbacks, closures, functional composition.
* Prefer **named function expressions** over anonymous for better stack traces.
* Avoid relying on old block-declaration quirks; assume ES6 standard (block-scoped).

---

üëâ Mnemonic: **‚ÄúDeclarations are Hoisted Leaders; Expressions are Inline Workers.‚Äù**

---

# üéõÔ∏è Default & Rest Parameters ‚Äî Cheat Card

**Concept:** Special function parameter features (ES6) for flexibility.

---

### Default Parameters

```js
function greet(name="Guest", lang="en") {
  return `Hi ${name}, lang=${lang}`;
}

greet();          // "Hi Guest, lang=en"
greet("Kalidas"); // "Hi Kalidas, lang=en"
```

* Values assigned **if argument is `undefined`**.
* Evaluated **at call time**, left-to-right.
* Can use earlier parameters as defaults.

---

### Rest Parameters

```js
function sum(...nums){ 
  return nums.reduce((a,b)=>a+b,0);
}

sum(1,2,3,4); // 10
```

* Collects ‚Äúthe rest‚Äù of args into an **array**.
* Must be **last parameter**.
* Replaces legacy `arguments` object in modern JS.

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Default param works only for `undefined`**

   * `greet(null)` ‚Üí `"Hi null"` (not default).
   * `greet(undefined)` ‚Üí uses default.
2. **Evaluation order**

   * Defaults evaluated **left to right**.
   * A param can use earlier ones:

     ```js
     function f(a=1, b=a+2){ return b; }
     f(); // 3
     ```
   * Using itself:

     ```js
     function f(a=a){ } // ‚ùå ReferenceError (TDZ)
     ```
3. **Scope**

   * Defaults create a new scope for each call.
   * Can shadow outer vars.
4. **Function.length**

   * Defaults reduce `.length` (count of params before first default).

   ```js
   (function(a,b=2){}).length // 1
   ```
5. **Rest param rules**

   * Must be last: `function f(...a, b){}` ‚ùå SyntaxError.
   * Only one rest param allowed.
6. **Rest param vs arguments**

   * Rest is a real **array**, `arguments` is array-like.
   * Arrow functions have no `arguments`, but can use rest.
   * `arguments` includes defaulted/skipped params; rest collects extra only.
7. **Performance**

   * Using rest can allocate new array on each call (minor perf hit in hot loops).
8. **Destructuring with defaults**

   ```js
   function f({a=1,b=2}={}){ return a+b; }
   f(); // 3
   ```

   * Defaults can be nested, but ordering still matters.

---

### Best Practices

* Use **defaults** instead of `param = param || value` (avoids `0`/`""` bugs).
* Use **rest** over `arguments` for clarity + real array methods.
* Place required params first, defaults after.
* Keep defaults simple (avoid heavy computation).
* Prefer destructured defaults for config objects.

---

üëâ Mnemonic: **‚ÄúDefault fills gaps, Rest gathers extras.‚Äù**

---

Do you want me to also cover **Destructured Parameters with Defaults** as a separate cheat card (since it combines two concepts and has unique quirks)?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **Arrow Functions**, covering syntax, `this` binding, lack of `arguments`, and every gotcha in one place.

---

# üèπ JavaScript Arrow Functions ‚Äî Cheat Card

**Concept:** Concise function expressions with lexical `this`, introduced in ES6.

---

### Syntax

```js
// Basic
const add = (a,b) => a+b;

// Single param, parens optional
const sq = x => x*x;

// No params
const hi = () => "Hello";

// Multi-line body
const sum = (a,b) => {
  const res = a+b;
  return res;
};

// Return object literal (wrap in parens)
const makeObj = () => ({a:1,b:2});
```

---

### Key Features

* Always **expressions**, never declarations.
* No own `this` ‚Üí inherits from enclosing scope (lexical).
* No `arguments` object ‚Üí use rest params `(...args)`.
* No `super` or `new.target`.
* Cannot be used as constructors (`new (()=>{})` ‚Üí ‚ùå TypeError).
* Shorter syntax for inline callbacks.

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **`this` binding**

   * Arrow inherits `this` from surrounding scope.
   * Great for callbacks:

     ```js
     class Timer {
       constructor(){ this.s=0; setInterval(()=>this.s++,1000); }
     }
     ```
   * But can cause bugs if you expect dynamic `this`:

     ```js
     const obj={val:42,fn:()=>this.val};
     obj.fn(); // undefined (this is not obj)
     ```
2. **No `arguments`**

   * Inside arrow, `arguments` is from outer function (if any).
   * Use rest params:

     ```js
     const fn=(...args)=>args;
     fn(1,2,3); // [1,2,3]
     ```
3. **Not constructible**

   * Cannot use `new` with arrow functions.
   * No `.prototype` property.
4. **Methods vs arrows**

   * Don‚Äôt use arrows for object methods needing `this`.
   * `obj={fn:()=>this}` ‚Üí `this` not bound to obj.
5. **Returning objects**

   * Must wrap in parens: `()=>({x:1})`.
   * Without parens: `()=>{x:1}` ‚Üí block, returns undefined.
6. **No name binding**

   * Arrow functions are always anonymous (name derived from variable).
   * Stack traces may be less clear than named function expressions.
7. **Lexical `super` and `new.target`**

   * Arrow inherits them from surrounding scope.
8. **Compatibility quirks**

   * Older engines (pre-ES6) don‚Äôt support.
   * Can confuse linters/transpilers if misused.
9. **Performance**

   * Tiny overhead in some engines vs declarations, but usually negligible.

---

### Best Practices

* ‚úÖ Use arrows for **short callbacks**, array methods, lexical `this` needs.
* ‚úÖ Use rest params for variadics instead of `arguments`.
* ‚ùå Don‚Äôt use arrows as object methods when you need dynamic `this`.
* ‚ùå Don‚Äôt use arrows as constructors.
* ‚úÖ Wrap return objects in `({})`.
* ‚úÖ Prefer named functions for recursion / clearer stack traces.

---

üëâ Mnemonic: **‚ÄúArrows are short, inherit `this`, but lack `arguments` & `new`.‚Äù**

---

Would you like me to create a **separate cheat card for `this`** (covering all contexts: global, function, arrow, class, strict, event handlers)? That one is usually a big interview topic.


Here‚Äôs your **Concept Mastery Cheat Sheet** for **First-Class & Higher-Order Functions**, made interview-ready and concise, with **all gotchas grouped in one block**.

---

# üèóÔ∏è JavaScript First-Class & Higher-Order Functions ‚Äî Cheat Card

**Concepts:**

* **First-Class Functions** ‚Üí Functions are treated as values (can be stored, passed, returned).
* **Higher-Order Functions (HOFs)** ‚Üí Functions that take other functions as args OR return functions.

---

### First-Class Functions

* Assigned to variables:

  ```js
  const greet = function(){ return "Hi"; };
  ```
* Passed as arguments:

  ```js
  setTimeout(()=>console.log("done"),1000);
  ```
* Returned from functions:

  ```js
  function outer(){ return ()=>"inside"; }
  const fn = outer(); fn(); // "inside"
  ```
* Stored in data structures:

  ```js
  const arr=[x=>x*2,y=>y+1];
  ```

---

### Higher-Order Functions

* **Takes functions as input**:

  ```js
  [1,2,3].map(x=>x*2);    // map takes callback
  ```
* **Returns function as output**:

  ```js
  const add = x => y => x+y;
  add(2)(3); // 5
  ```
* **Both**:

  ```js
  const twice = f => x => f(f(x));
  const inc = x=>x+1;
  twice(inc)(5); // 7
  ```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Context loss**

   * Passing object methods as callbacks loses `this`:

     ```js
     const obj={x:1,fn(){return this.x}};
     setTimeout(obj.fn,1000); // undefined
     ```

     (fix: `obj.fn.bind(obj)` or arrow wrapper).
2. **Callback hell**

   * Nesting many HOF callbacks ‚Üí unreadable. (Solved via Promises/async).
3. **Performance pitfalls**

   * Overusing HOFs (`map`, `filter`, `reduce`) in tight loops may be slower than plain loops.
4. **Recursion limits**

   * Returning functions recursively may blow stack (tail-call not widely optimized).
5. **Anonymous vs named**

   * Anonymous callbacks hinder debugging stack traces. Prefer named expressions.
6. **Closures in HOFs**

   * HOFs often rely on closures; careless use can trap memory:

     ```js
     function wrapper(){ const big=[]; return ()=>big; }
     ```

     (closure keeps `big` alive).
7. **Arguments mismatch**

   * HOFs like `map` pass `(element,index,array)` to callback ‚Äî forgetting extra args can cause bugs:

     ```js
     ["1","2","3"].map(parseInt); // [1,NaN,NaN]
     ```
8. **Partial application vs currying confusion**

   * Returning functions may confuse devs if not documented clearly.
9. **Async callbacks**

   * HOFs like `forEach` don‚Äôt await async callbacks:

     ```js
     [1,2].forEach(async x=>await doWork(x)); // not sequential
     ```

---

### Best Practices

* ‚úÖ Embrace first-class functions ‚Üí pass, store, return freely.
* ‚úÖ Use named functions in HOFs for clarity.
* ‚úÖ Prefer modern async/await over deeply nested callbacks.
* ‚úÖ Document when functions return functions (currying, partials).
* ‚ùå Don‚Äôt overuse HOFs in performance-critical loops.
* ‚úÖ Use `.map/.filter/.reduce` for clarity, but know their extra args.

---

üëâ Mnemonic: **‚ÄúFirst-Class = Treated like values. Higher-Order = Functions that use functions.‚Äù**

---

Would you like me to follow this up with a **dedicated cheat card on Closures** (since they‚Äôre tightly tied to first-class + HOFs and often confused in interviews)?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **Function Scope vs Block Scope** in JavaScript ‚Äî sharp, compact, and with **all gotchas grouped together**.

---

# üìç JavaScript Function Scope vs Block Scope ‚Äî Cheat Card

**Concept:** Determines where variables are accessible in code.

---

### Function Scope

* Variables visible **throughout function**, not outside.
* `var` is **function-scoped**.

```js
function test(){
  var x=1;
  if(true){ var x=2; }
  console.log(x); // 2
}
console.log(x); // ‚ùå ReferenceError
```

---

### Block Scope

* Variables visible only **inside `{}`** (if, for, while, etc).
* `let` and `const` are **block-scoped**.

```js
{
  let y=10; const z=20;
  console.log(y,z); // 10 20
}
console.log(y); // ‚ùå ReferenceError
```

---

### Temporal Dead Zone (TDZ)

* `let`/`const` hoisted but **uninitialized** until declaration.

```js
{
  console.log(a); // ‚ùå ReferenceError
  let a=5;
}
```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **`var` leaks out of blocks**

   ```js
   if(true){ var x=1; }
   console.log(x); // 1
   ```
2. **Loop quirks**

   * `var` ‚Üí one binding across loop ‚Üí closure bug:

     ```js
     for(var i=0;i<3;i++) setTimeout(()=>console.log(i)); // 3,3,3
     ```
   * `let` ‚Üí new binding per iteration:

     ```js
     for(let i=0;i<3;i++) setTimeout(()=>console.log(i)); // 0,1,2
     ```
3. **TDZ surprises**

   * Access before `let/const` ‚Üí ReferenceError.
   * Even `typeof` fails:

     ```js
     console.log(typeof a); // ‚ùå
     let a;
     ```
4. **Shadowing**

   * Inner `let/const` can shadow outer vars.
   * Can confuse scope resolution.
5. **Function declarations in blocks**

   * Sloppy mode: function declarations inside `{}` hoisted to enclosing function/global.
   * ES6 strict: block-scoped.
   * Behavior varies across environments.
6. **Global scope differences**

   * `var` ‚Üí attaches to `window/globalThis`.
   * `let`/`const` ‚Üí do **not** attach.
7. **Redeclaration rules**

   * `var x=1; var x=2;` ‚úÖ allowed.
   * `let x=1; let x=2;` ‚ùå SyntaxError.
   * Mixing `var` + `let/const` in same scope ‚ùå.
8. **Closures**

   * Inner functions capture variables by scope.
   * With `var`, all closures may share same reference (loop bug).

---

### Best Practices

* ‚úÖ Prefer **`let`/`const`** ‚Üí block scope safer.
* ‚úÖ Use `const` by default, `let` if reassignment needed.
* ‚ùå Avoid `var`.
* ‚úÖ Be mindful of shadowing; keep variable names distinct.
* ‚úÖ Always declare variables at top of block for clarity.

---

üëâ Mnemonic: **‚ÄúVar is function-scoped leaky, Let/Const are block-scoped safe.‚Äù**

---

Would you like me to also do a **dedicated Closures cheat card** next (since closures depend directly on understanding scope)?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **Closures** ‚Äî complete with syntax, use-cases (data privacy, memoization, once-only), and every gotcha grouped in one block.

---

# üîí JavaScript Closures ‚Äî Cheat Card

**Concept:** A closure is a function that ‚Äúremembers‚Äù variables from its **lexical scope** even after the outer function has finished executing.

---

### Syntax

```js
function outer(){
  let count=0;
  return function inner(){
    count++;
    return count;
  };
}
const inc=outer();
inc(); // 1
inc(); // 2
```

---

### Core Behavior

* Inner function **captures references** to outer variables, not copies.
* Preserves **lexical scope chain** at creation time.
* Enables **persistent state** across calls.

---

### Common Use-Cases

1. **Data Privacy / Encapsulation**

   ```js
   function counter(){
     let c=0;
     return {inc:()=>++c,get:()=>c};
   }
   const ctr=counter();
   ctr.inc(); // 1
   ctr.get(); // 1 (c is private)
   ```
2. **Memoization / Caching**

   ```js
   function memoize(fn){
     const cache={};
     return arg => cache[arg] ?? (cache[arg]=fn(arg));
   }
   const square=memoize(x=>x*x);
   square(4); // caches 16
   ```
3. **Once-Only Execution**

   ```js
   function once(fn){
     let called=false, result;
     return (...args)=>{
       if(!called){ result=fn(...args); called=true; }
       return result;
     };
   }
   const init=once(()=>console.log("run"));
   init(); // run
   init(); // (no effect)
   ```
4. **Partial Application / Currying**

   ```js
   const add=a=>b=>a+b;
   add(2)(3); // 5
   ```
5. **Event Handlers**

   ```js
   for(let i=0;i<3;i++){
     setTimeout(()=>console.log(i),1000);
   }
   ```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Reference, not copy**

   * All closures share the same variable, not its value at creation.

   ```js
   var funcs=[];
   for(var i=0;i<3;i++) funcs.push(()=>i);
   funcs[0](); // 3 (not 0!)
   ```

   (Fix: use `let` or IIFE).
2. **Memory leaks**

   * Long-lived closures can hold large objects in memory.
   * Be careful in event listeners, callbacks, DOM references.
3. **Performance**

   * Excessive closures in hot code paths can increase GC pressure.
4. **Accidental sharing**

   * Nested closures can unintentionally mutate shared state.
5. **Debugging difficulty**

   * Variables may not show expected values due to late binding.
6. **Hoisting + TDZ**

   * Closure captures by reference, so TDZ rules apply for `let/const`.
7. **Eval / with interactions**

   * Can interfere with lexical scoping (sloppy mode).

---

### Best Practices

* ‚úÖ Use closures for **stateful functions** (counters, caches).
* ‚úÖ Prefer `let/const` in loops to avoid classic closure bugs.
* ‚úÖ Release closures holding large objects when not needed.
* ‚úÖ Use named functions when possible for better stack traces.
* ‚ùå Avoid deep nesting; extract closures into helpers for clarity.

---

üëâ Mnemonic: **‚ÄúClosure = Function + Lexical Scope = Private Memory.‚Äù**

---

Would you like me to now create a **dedicated cheat card on Currying & Partial Application** (since they are powerful closure patterns often asked in interviews)?

Here‚Äôs your **Concept Mastery Cheat Sheet** for **Recursion** in JavaScript ‚Äî compact, practical, and with **all gotchas grouped together**.

---

# üîÅ JavaScript Recursion ‚Äî Cheat Card

**Concept:** A function that calls itself until a base condition is met.

---

### Syntax

```js
// Direct recursion
function fact(n){
  if(n<=1) return 1;
  return n*fact(n-1);
}

// Indirect recursion
function a(x){ if(x>0) b(x-1); }
function b(y){ if(y>0) a(y-1); }
```

---

### Types

* **Direct** ‚Üí function calls itself.
* **Indirect/Mutual** ‚Üí multiple functions call each other.
* **Tail recursion** ‚Üí recursive call is last statement (can be optimized in some langs, but not reliably in JS).

---

### Use-Cases

1. **Math problems** ‚Üí factorial, Fibonacci, GCD.
2. **Tree/Graph traversal** ‚Üí DOM, JSON, AST, file systems.
3. **Divide & conquer** ‚Üí quicksort, mergesort, binary search.
4. **Backtracking** ‚Üí N-Queens, Sudoku, pathfinding.
5. **Flattening structures** ‚Üí arrays, nested objects.

---

### Examples

```js
// Factorial
const factorial = n => n<=1 ? 1 : n*factorial(n-1);

// Sum of nested array
function sum(arr){
  return arr.reduce((a,v)=>a+(Array.isArray(v)?sum(v):v),0);
}

// DOM traversal
function walk(node){
  console.log(node.tagName);
  node.childNodes.forEach(walk);
}
```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Base case missing** ‚Üí infinite recursion ‚Üí RangeError: Maximum call stack size exceeded.
2. **Stack overflow** ‚Üí JS doesn‚Äôt guarantee tail-call optimization. Large recursions can crash.
3. **Inefficiency**

   * Na√Øve Fibonacci: exponential calls.
   * Fix with memoization or iteration.
4. **Indirect recursion complexity** ‚Üí harder to debug if many functions mutually recurse.
5. **Arguments object** ‚Üí recursive functions with `arguments.callee` are banned in strict mode.
6. **Named vs anonymous recursion**

   * Anonymous function expressions need a name inside for self-reference:

     ```js
     const f = function fact(n){ return n<=1?1:n*fact(n-1); };
     ```
   * Without name, can‚Äôt self-call.
7. **Async recursion**

   * Recursive `setTimeout` or `async/await` introduces event loop delays; different from sync recursion.
8. **Closures in recursion**

   * Recursive inner functions may capture outer vars and cause leaks.
9. **Debugging stack traces**

   * Anonymous recursion ‚Üí poor trace readability.

---

### Best Practices

* ‚úÖ Always define a clear **base case**.
* ‚úÖ Use **iteration** when recursion depth may be large.
* ‚úÖ Memoize results for heavy recursive problems.
* ‚úÖ Use named functions for better stack traces.
* ‚úÖ For async tasks, use `async/await` recursion carefully.

---

üëâ Mnemonic: **‚ÄúRecursion = Base + Self-call, else Stack Fall.‚Äù**

---

Would you like me to follow this with a **dedicated cheat card on Asynchronous Recursion** (e.g., recursion with `async/await` or `setTimeout` for large data to avoid stack overflow)?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **Immediately Invoked Function Expressions (IIFE)** ‚Äî sharp, compact, and with **all gotchas grouped together**.

---

# ‚ö° JavaScript IIFE ‚Äî Cheat Card

**Concept:** Function expression that executes immediately after it‚Äôs defined.

---

### Syntax

```js
// Classic
(function(){ console.log("run"); })();

// Arrow IIFE
(() => console.log("run"))();

// With params
((x,y) => console.log(x+y))(2,3);

// Named IIFE (for recursion/debugging)
(function fact(n){ return n<=1?1:n*fact(n-1); })(5);
```

---

### Purpose

* Create a **new scope** to avoid polluting global namespace.
* Encapsulate private variables.
* Initialize modules/configs.
* Run once-only code (setup, polyfills).

---

### Variants

* **Unary operator trick** (forces expression):

  ```js
  !function(){ console.log("hi"); }();
  +function(){ console.log("hi"); }();
  ```
* **Async IIFE** (ES2017+):

  ```js
  (async () => {
    const res = await fetch("/data");
    console.log(await res.json());
  })();
  ```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Declaration vs Expression**

   * `function foo(){}()` ‚ùå SyntaxError (declaration not callable directly).
   * Wrap in `()` to turn into expression: `(function foo(){})()`.
2. **Arrow IIFE & this**

   * Arrow IIFE doesn‚Äôt bind its own `this`; inherits lexical `this`.
   * May differ from classic IIFE behavior.
3. **Semicolon safety**

   * If previous line doesn‚Äôt end with `;`, IIFE may be misparsed.

   ```js
   let a=5
   (function(){})(); // ‚ùå may break
   ```

   ‚Üí Always end prev line with `;`.
4. **Debugging**

   * Anonymous IIFEs give poor stack traces. Prefer named IIFEs when debugging.
5. **Overuse**

   * In ES6+, block scope (`{}` + `let`/`const`) or modules often better than IIFEs.
6. **Async pitfalls**

   * Async IIFE returns a promise ‚Äî forgetting to `await` it can cause race bugs.
7. **Recursion in IIFE**

   * Anonymous IIFE cannot self-call recursively; must be named.

---

### Best Practices

* ‚úÖ Use for one-time setup, initialization, or isolating scope.
* ‚úÖ Prefer **named IIFEs** for recursion & debugging.
* ‚úÖ Always place semicolon before starting an IIFE.
* ‚ùå Don‚Äôt use IIFEs for everything; modern `let/const` + modules reduce need.
* ‚úÖ Use async IIFEs for top-level `await` in non-module scripts.

---

üëâ Mnemonic: **‚ÄúIIFE = Expression + () + () ‚Üí Runs instantly.‚Äù**

---

Do you want me to continue with a **dedicated cheat card on Modules (ES6 import/export)** next, since IIFEs were often a pre-ES6 way to simulate modular scope?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **Callback Functions** ‚Äî compact, interview-ready, and with **all gotchas grouped together**.

---

# üîÑ JavaScript Callback Functions ‚Äî Cheat Card

**Concept:** A function passed as an argument to another function, executed later (synchronously or asynchronously).

---

### Syntax

```js
// Synchronous callback
function greet(name, cb){
  console.log("Hello " + name);
  cb();
}
greet("Kalidas", () => console.log("Done"));

// Asynchronous callback
setTimeout(() => console.log("Runs later"), 1000);
```

---

### Use-Cases

* Event handling (`button.addEventListener("click", cb)`)
* Array methods (`map`, `filter`, `reduce`, `forEach`)
* Async operations (`fs.readFile("file.txt", cb)`)
* Custom control flow (middleware, pipelines)

---

### Types

* **Synchronous** ‚Üí executed immediately (`map`, `filter`).
* **Asynchronous** ‚Üí executed later (I/O, timers, network).

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Callback hell (Pyramid of Doom)**

   * Deep nesting of callbacks ‚Üí unreadable, hard to maintain.
   * Fixed by Promises/async‚Äìawait.
2. **Error handling inconsistency**

   * Node.js style uses `(err, result)` convention.
   * Forgetting to handle errors leads to silent failures.
3. **Multiple calls**

   * Callback may be invoked more than once if not guarded.
   * Can cause bugs like duplicate requests.
4. **Lost `this` context**

   ```js
   obj.method(function(){ console.log(this); }); // not obj
   ```

   (Fix: use arrow function or `bind`).
5. **Order of execution confusion**

   * Async callbacks run later in event loop ‚Üí not in sequence.
   * Example:

     ```js
     setTimeout(()=>console.log("A"),0);
     console.log("B"); // B before A
     ```
6. **Arguments mismatch**

   * Some APIs pass multiple args (e.g., `map((el, i, arr)=>...)`).
   * Forgetting extra args can cause subtle bugs.
7. **Memory leaks**

   * Callbacks registered but never removed (event listeners) keep objects alive.
8. **Zalgo problem**

   * Callback may run sync *or* async depending on conditions ‚Üí unpredictable flow.
     (Solved via Promises).
9. **Anonymous callbacks**

   * Harder to debug (stack traces show `<anonymous>`).
10. **Race conditions**

    * Multiple async callbacks updating same state cause inconsistent results.

---

### Best Practices

* ‚úÖ Use **named functions** for clarity and debugging.
* ‚úÖ Always handle errors in async callbacks.
* ‚úÖ Avoid deep nesting ‚Üí refactor into Promises/async-await.
* ‚úÖ Remove event listeners after use to prevent leaks.
* ‚úÖ Document the expected signature `(args‚Ä¶)` of callbacks.
* ‚ùå Don‚Äôt rely on execution order in async callbacks.

---

üëâ Mnemonic: **‚ÄúCallback = Function Later, Beware Hell & Context.‚Äù**

---

Would you like me to follow this with a **dedicated cheat card on Promises** (since they‚Äôre the modern evolution of callbacks and interviewers love comparing them)?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **the `arguments` object** ‚Äî compact, full coverage, and with **all gotchas grouped together**.

---

# üì¶ JavaScript `arguments` Object ‚Äî Cheat Card

**Concept:** Array-like object available inside **non-arrow functions** that holds all passed arguments.

---

### Syntax

```js
function demo(a,b){
  console.log(arguments[0]); // first arg
  console.log(arguments.length); // count
}
demo(10,20,30); // 10, 3
```

---

### Properties

* **`arguments.length`** ‚Üí number of arguments passed.
* **`arguments[i]`** ‚Üí access by index.
* **`arguments.callee`** ‚Üí reference to current function (‚ùå forbidden in strict mode).
* **Not an array** ‚Üí no `map`, `filter` directly. Convert with `[...arguments]` or `Array.from(arguments)`.

---

### Relationship with Parameters

* **Sloppy mode**: arguments & named params are linked (changes reflect both).
* **Strict mode**: arguments & params are decoupled.

```js
function f(a){
  a=99;
  console.log(arguments[0]);
}
f(1); // sloppy: 99, strict: 1
```

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Not available in arrow functions**

   ```js
   const f = () => console.log(arguments); // ‚ùå ReferenceError
   ```
2. **Not a real array**

   * Missing array methods. Must convert for iteration.
3. **Strict vs sloppy mode**

   * In sloppy mode, params ‚Üî arguments linked.
   * In strict mode, they are independent.
4. **Default/rest params interaction**

   * Defaults/rest **don‚Äôt update** `arguments`.

   ```js
   function f(a=5){ console.log(arguments.length); }
   f(); // 0, not 1
   ```
5. **Extra arguments**

   * Ignored in param list but present in `arguments`.

   ```js
   function g(a,b){ console.log(arguments[2]); }
   g(1,2,3); // 3
   ```
6. **Fewer arguments**

   * Missing ones are `undefined`.
7. **`arguments.callee`**

   * Deprecated; forbidden in strict mode.
   * Alternative: use named function expressions.
8. **Performance**

   * Historically slower in some engines due to aliasing. Modern engines optimized, but rest params preferred.
9. **Shadowing**

   * Declaring a variable/param named `arguments` shadows the object.
10. **ES6 preference**

    * Modern JS favors **rest parameters (`...args`)** over `arguments`.

---

### Best Practices

* ‚úÖ Use **rest params (`...args`)** for modern code.
* ‚úÖ Convert `arguments` with `[...arguments]` or `Array.from`.
* ‚ùå Don‚Äôt use `arguments.callee`.
* ‚úÖ Be aware of strict vs sloppy differences.
* ‚úÖ Use named functions instead of relying on `callee`.

---

üëâ Mnemonic: **‚ÄúArguments = Array-like past, Rest = modern future.‚Äù**

---

Do you want me to next build a **cheat card on Rest Parameters vs `arguments`** (direct comparison, since interviewers often ask why rest is better)?


Here‚Äôs your **Concept Mastery Cheat Sheet** for **Tail Call Optimization (TCO)** in JavaScript ‚Äî focusing on the ES6 spec, reality, and all gotchas grouped together.

---

# üîö JavaScript Tail Call Optimization ‚Äî Cheat Card

**Concept:** An optimization where **a function call in tail position** (last action before return) reuses the current stack frame instead of creating a new one ‚Üí avoids stack overflow.

---

### Syntax (Tail Position)

```js
"use strict"; // required per spec
function fact(n, acc=1){
  if(n<=1) return acc;     // base case
  return fact(n-1, n*acc); // tail call (last action)
}
fact(5); // 120
```

---

### ES6 Spec Notes

* Defined in **ECMAScript 2015 (ES6)**.
* Tail call must be:

  1. In **strict mode**.
  2. A direct call (not inside `try/finally`, `with`, etc).
  3. Last action of the function (`return f(...)`).
  4. Not wrapped in an operation (`return 1 + f(x)` ‚ùå).
* Replaces current frame instead of adding new one.

---

### Benefits

* Prevents stack overflow on deep recursion.
* Improves memory efficiency.
* Enables functional-style recursion for large inputs.

---

### Gotchas ‚ö†Ô∏è (Exhaustive)

1. **Not widely implemented**

   * Safari (WebKit) implemented **proper TCO**.
   * V8 (Chrome/Node) & SpiderMonkey (Firefox) **do not support** TCO.
   * Means spec compliance ‚â† engine compliance.
2. **Strict mode required**

   * Without `"use strict"`, spec forbids TCO.
3. **Only proper tail calls**

   * Must be exactly `return fn(...)`.
   * Wrapping or adding ops prevents optimization.

   ```js
   return 1 + fn(x); // ‚ùå not tail position
   return fn(x) * 2; // ‚ùå
   ```
4. **Debugging trade-off**

   * Stack traces shorter, harder to debug if TCO applied.
5. **Async recursion unaffected**

   * TCO applies only to synchronous calls.
   * `await fn()` always creates new promise/frame.
6. **Spec vs real life**

   * ES6 spec mandates TCO, but most engines skipped for performance & debuggability reasons.
   * So writing code expecting TCO is unsafe today.
7. **Manual trampolining often needed**

   * Simulate TCO using loops or ‚Äútrampoline‚Äù functions.

---

### Workarounds (Without Native TCO)

```js
// Trampoline technique
function trampoline(fn){
  while(typeof fn==="function"){ fn=fn(); }
  return fn;
}

function fact(n, acc=1){
  return n<=1 ? acc : () => fact(n-1, acc*n);
}
trampoline(fact(100000)); // works without overflow
```

---

### Best Practices

* ‚úÖ Don‚Äôt rely on spec TCO in production ‚Üí assume not supported.
* ‚úÖ Use iteration for very deep recursion in JS.
* ‚úÖ Use trampolines for safe recursive patterns.
* ‚úÖ Use memoization/loops for performance-critical recursive tasks.

---

üëâ Mnemonic: **‚ÄúTail Call = Return Call Only, but Engines Rarely Honor It.‚Äù**

---

Do you want me to follow this with a **dedicated cheat card on Recursion Alternatives** (loops, trampolines, generators) ‚Äî since interviewers often ask ‚Äúwhat if JS doesn‚Äôt optimize tail calls‚Äù?
